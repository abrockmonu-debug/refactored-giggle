<!DOCTYPE html>
<html>
<head>
    <title>Doubling Merge Game</title>
    <style>
        body {
            background-color: #f0f0f0;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            font-family: Arial, sans-serif;
            flex-direction: column;
        }

        #game-container {
            border: 2px solid #333;
            background-color: #fff;
            position: relative;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        }

        #game-info {
            text-align: center;
            margin-bottom: 20px;
        }

        #score-display {
            font-size: 2em;
            font-weight: bold;
            color: #4CAF50;
        }

        #next-number-display {
            font-size: 1.2em;
            color: #555;
            margin-top: 10px;
        }
    </style>
</head>
<body>

    <div id="game-info">
        <h1>Doubling Merge</h1>
        <div id="score-display">Score: 0</div>
        <div id="next-number-display">Next: </div>
    </div>
    <canvas id="game-canvas"></canvas>

    <script>
        const canvas = document.getElementById('game-canvas');
        const ctx = canvas.getContext('2d');
        const gameContainer = document.getElementById('game-container');
        const scoreDisplay = document.getElementById('score-display');
        const nextNumberDisplay = document.getElementById('next-number-display');

        // Smaller dimensions for the canvas
        const CANVAS_WIDTH = 300;
        const CANVAS_HEIGHT = 500;

        canvas.width = CANVAS_WIDTH;
        canvas.height = CANVAS_HEIGHT;
        gameContainer.style.width = CANVAS_WIDTH + 'px';
        gameContainer.style.height = CANVAS_HEIGHT + 'px';

        let circles = [];
        let coins = [];
        let score = 0;
        let nextNumber = getRandomNumber();
        let droppingCircle = null;
        let gameOver = false;
        const merging = new Set();
        const coinSpawnInterval = 5000;
        let lastCoinSpawnTime = 0;

        const colors = {
            1: '#e74c3c', // red
            2: '#3498db', // blue
            4: '#2ecc71', // green
            8: '#f1c40f', // yellow
            16: '#9b59b6', // purple
            32: '#34495e', // dark blue
            64: '#e67e22', // orange
            128: '#1abc9c', // turquoise
            256: '#d35400', // pumpkin
            512: '#c0392b', // dark red
            1024: '#8e44ad',
            2048: '#2980b9',
        };

        function getRandomNumber() {
            const numbers = [1, 2, 4, 8, 16];
            const weights = [0.5, 0.3, 0.1, 0.07, 0.03];
            let sum = 0;
            let r = Math.random();
            for (let i = 0; i < weights.length; i++) {
                sum += weights[i];
                if (r < sum) {
                    return numbers[i];
                }
            }
            return numbers[0];
        }

        function getRadiusForNumber(number) {
            return 12 + Math.log2(number) * 2.5;
        }

        function createCircle(x, y, number, isFalling = false, type = 'number') {
            return {
                x: x,
                y: y,
                radius: getRadiusForNumber(number),
                number: number,
                color: colors[number] || '#333',
                vy: 0,
                isFalling: isFalling,
                type: type
            };
        }

        function createCoin(x, y) {
            return {
                x: x,
                y: y,
                radius: 8,
                color: 'gold',
                isCollected: false
            };
        }

        function drawCircles() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = '#f9f9f9';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw game over line
            ctx.strokeStyle = 'red';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(0, 40);
            ctx.lineTo(canvas.width, 40);
            ctx.stroke();

            circles.forEach(circle => {
                ctx.beginPath();
                ctx.arc(circle.x, circle.y, circle.radius, 0, Math.PI * 2);
                ctx.fillStyle = circle.color;
                ctx.fill();
                ctx.strokeStyle = '#333';
                ctx.stroke();

                if (circle.type === 'number') {
                    ctx.fillStyle = '#fff';
                    ctx.font = `${Math.min(circle.radius * 0.9, 25)}px Arial`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(circle.number, circle.x, circle.y);
                } else if (circle.type === 'bomb') {
                    ctx.fillStyle = '#fff';
                    ctx.font = `${Math.min(circle.radius * 0.8, 25)}px Arial`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText('💣', circle.x, circle.y);
                } else if (circle.type === 'wildcard') {
                    ctx.fillStyle = '#fff';
                    ctx.font = `${Math.min(circle.radius * 0.8, 25)}px Arial`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText('⭐', circle.x, circle.y);
                }
            });

            coins.forEach(coin => {
                ctx.beginPath();
                ctx.arc(coin.x, coin.y, coin.radius, 0, Math.PI * 2);
                ctx.fillStyle = coin.color;
                ctx.fill();
                ctx.strokeStyle = 'gold';
                ctx.stroke();
            });
        }

        function updateCircles() {
            circles.forEach(circle => {
                circle.vy += 0.5;
                circle.y += circle.vy;

                // Check for collision with bottom
                if (circle.y + circle.radius >= canvas.height) {
                    circle.y = canvas.height - circle.radius;
                    circle.vy = 0;
                }
                
                // Check for collision with other circles
                circles.forEach(other => {
                    if (circle !== other) {
                        const dx = other.x - circle.x;
                        const dy = other.y - circle.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        const minDistance = circle.radius + other.radius;

                        if (distance < minDistance) {
                            // Simple collision response
                            const angle = Math.atan2(dy, dx);
                            const overlap = minDistance - distance;
                            circle.x -= Math.cos(angle) * overlap / 2;
                            circle.y -= Math.sin(angle) * overlap / 2;
                            other.x += Math.cos(angle) * overlap / 2;
                            other.y += Math.sin(angle) * overlap / 2;

                            // Merge logic
                            if (circle.type === 'number' && other.type === 'number' && circle.number === other.number && !merging.has(circle) && !merging.has(other)) {
                                merging.add(circle);
                                merging.add(other);
                                circles = circles.filter(c => c !== circle && c !== other);
                                const mergedNumber = circle.number * 2;
                                const mergedCircle = createCircle((circle.x + other.x) / 2, (circle.y + other.y) / 2, mergedNumber, true);
                                circles.push(mergedCircle);
                                score += mergedNumber;
                                scoreDisplay.textContent = `Score: ${score}`;
                                merging.delete(circle);
                                merging.delete(other);
                            } else if ((circle.type === 'wildcard' || other.type === 'wildcard') && !merging.has(circle) && !merging.has(other)) {
                                const wildcard = circle.type === 'wildcard' ? circle : other;
                                const otherCircle = circle.type === 'wildcard' ? other : circle;
                                merging.add(wildcard);
                                merging.add(otherCircle);
                                circles = circles.filter(c => c !== wildcard && c !== otherCircle);
                                const mergedNumber = otherCircle.number * 2;
                                const mergedCircle = createCircle((wildcard.x + otherCircle.x) / 2, (wildcard.y + otherCircle.y) / 2, mergedNumber, true);
                                circles.push(mergedCircle);
                                score += mergedNumber;
                                scoreDisplay.textContent = `Score: ${score}`;
                                merging.delete(wildcard);
                                merging.delete(otherCircle);
                            } else if ((circle.type === 'bomb' || other.type === 'bomb') && !merging.has(circle) && !merging.has(other)) {
                                const bomb = circle.type === 'bomb' ? circle : other;
                                circles = circles.filter(c => {
                                    const dist = Math.sqrt(Math.pow(c.x - bomb.x, 2) + Math.pow(c.y - bomb.y, 2));
                                    return dist > 120; // Smaller radius for the bomb explosion
                                });
                                score += 50;
                                scoreDisplay.textContent = `Score: ${score}`;
                            }
                        }
                    }
                });
            });

            // Check for game over
            circles.forEach(circle => {
                if (circle.y - circle.radius < 40) {
                    gameOver = true;
                    alert(`Game Over! Your final score is: ${score}`);
                }
            });
        }

        function gameLoop(timestamp) {
            if (!gameOver) {
                updateCircles();
                drawCircles();

                // Spawn a new coin
                if (timestamp - lastCoinSpawnTime > coinSpawnInterval) {
                    const coinX = Math.random() * (CANVAS_WIDTH - 16) + 8;
                    const coinY = Math.random() * (CANVAS_HEIGHT - 60) + 50;
                    coins.push(createCoin(coinX, coinY));
                    lastCoinSpawnTime = timestamp;
                }

                requestAnimationFrame(gameLoop);
            }
        }

        canvas.addEventListener('click', (event) => {
            if (droppingCircle) return;
            if (gameOver) return;

            const rect = canvas.getBoundingClientRect();
            const clickX = event.clientX - rect.left;
            const clickY = event.clientY - rect.top;

            // Check if a coin was clicked
            for (let i = coins.length - 1; i >= 0; i--) {
                const coin = coins[i];
                const dist = Math.sqrt(Math.pow(clickX - coin.x, 2) + Math.pow(clickY - coin.y, 2));
                if (dist < coin.radius) {
                    score += 10;
                    scoreDisplay.textContent = `Score: ${score}`;
                    coins.splice(i, 1);
                    return;
                }
            }

            // Otherwise, drop a new circle
            const r = Math.random();
            let newCircle;
            if (r < 0.05) { // 5% chance for a power-up
                if (Math.random() < 0.5) {
                    newCircle = createCircle(clickX, 0, 1, true, 'bomb');
                } else {
                    newCircle = createCircle(clickX, 0, 1, true, 'wildcard');
                }
            } else {
                newCircle = createCircle(clickX, 0, nextNumber, true);
            }
            circles.push(newCircle);

            nextNumber = getRandomNumber();
            nextNumberDisplay.textContent = `Next: ${nextNumber}`;
        });

        // Initial setup
        nextNumberDisplay.textContent = `Next: ${nextNumber}`;
        gameLoop(0);
    </script>
</body>
</html>
